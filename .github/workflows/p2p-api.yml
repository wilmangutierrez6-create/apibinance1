name: Binance P2P Data Fetcher

on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  fetch-p2p-data:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout cÃ³digo
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configurar Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Instalar dependencias
      run: |
        python -m pip install --upgrade pip
        pip install requests pandas
    
    - name: Crear carpetas necesarias
      run: |
        mkdir -p backend
        mkdir -p data
    
    - name: Crear script Python
      run: |
        cat > backend/p2p-api.py << 'EOF'
#!/usr/bin/env python3
"""
Script para obtener datos P2P de Binance - VersiÃ³n robusta
"""
import os
import sys
import json
import time
import hmac
import hashlib
import requests
import pandas as pd
import urllib.parse
from datetime import datetime

print("=" * 60)
print("ðŸš€ INICIANDO SCRIPT P2P DE BINANCE")
print("=" * 60)

# ConfiguraciÃ³n desde Secrets
API_KEY = os.environ.get("BINANCE_API_KEY", "")
API_SECRET = os.environ.get("BINANCE_API_SECRET", "")

print(f"âœ“ API_KEY obtenida: {'SÃ' if API_KEY else 'NO'} ({len(API_KEY)} caracteres)")
print(f"âœ“ API_SECRET obtenida: {'SÃ' if API_SECRET else 'NO'} ({len(API_SECRET)} caracteres)")

# Validar credenciales
if not API_KEY or not API_SECRET:
    print("âŒ ERROR: Faltan credenciales de API")
    print("Por favor, configura los secrets BINANCE_API_KEY y BINANCE_API_SECRET en GitHub")
    sys.exit(1)

BASE_URL = "https://api.binance.com"

def sign(params, secret):
    """Firmar parÃ¡metros con HMAC SHA256"""
    try:
        query = urllib.parse.urlencode(params)
        signature = hmac.new(
            secret.encode('utf-8'),
            query.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        return signature
    except Exception as e:
        print(f"âŒ Error firmando parÃ¡metros: {e}")
        return ""

def get_orders(trade_type, max_pages=2):
    """Obtener Ã³rdenes P2P"""
    page = 1
    orders = []
    
    print(f"\nðŸ“Š Obteniendo Ã³rdenes de {trade_type}...")
    
    while page <= max_pages:
        try:
            print(f"  PÃ¡gina {page} de {max_pages}")
            
            payload = {
                "tradeType": trade_type,
                "page": page,
                "rows": 20,  # Reducido para pruebas
                "timestamp": int(time.time() * 1000)
            }
            
            signature = sign(payload, API_SECRET)
            if not signature:
                break
                
            payload["signature"] = signature
            headers = {"X-MBX-APIKEY": API_KEY}

            response = requests.get(
                BASE_URL + "/sapi/v1/c2c/orderMatch/listUserOrderHistory",
                headers=headers,
                params=payload,
                timeout=30
            )
            
            print(f"  CÃ³digo HTTP: {response.status_code}")
            
            if response.status_code != 200:
                print(f"  âŒ Error HTTP: {response.text[:200]}")
                break
                
            data = response.json()
            
            if "data" not in data:
                print(f"  âŒ Respuesta inesperada: {data}")
                break
                
            if len(data["data"]) == 0:
                print(f"  âœ“ No mÃ¡s Ã³rdenes en pÃ¡gina {page}")
                break
                
            orders.extend(data["data"])
            print(f"  âœ“ {len(data['data'])} Ã³rdenes obtenidas")
            
            page += 1
            time.sleep(0.5)  # Pausa para no sobrecargar la API
            
        except requests.exceptions.RequestException as e:
            print(f"  âŒ Error de conexiÃ³n: {e}")
            break
        except Exception as e:
            print(f"  âŒ Error inesperado: {e}")
            import traceback
            traceback.print_exc()
            break
    
    print(f"  Total Ã³rdenes {trade_type}: {len(orders)}")
    return orders

def main():
    """FunciÃ³n principal"""
    try:
        # 1. Obtener datos
        print("\n" + "=" * 60)
        print("ðŸ“¥ OBTENIENDO DATOS DE LA API")
        print("=" * 60)
        
        buy_orders = get_orders("BUY")
        sell_orders = get_orders("SELL")
        
        all_orders = buy_orders + sell_orders
        
        if not all_orders:
            print("\nâš ï¸ No se encontraron Ã³rdenes")
            result = {
                "success": False, 
                "message": "No se encontraron operaciones en la cuenta",
                "timestamp": datetime.now().isoformat()
            }
        else:
            print(f"\nâœ… Total Ã³rdenes obtenidas: {len(all_orders)}")
            
            # 2. Procesar datos
            df = pd.DataFrame(all_orders)
            
            # Filtrar solo completadas
            completed_df = df[df["orderStatus"] == "COMPLETED"]
            print(f"âœ… Ã“rdenes completadas: {len(completed_df)}")
            
            if completed_df.empty:
                print("âš ï¸ No hay Ã³rdenes completadas")
                result = {
                    "success": False,
                    "message": "No hay operaciones completadas recientemente",
                    "timestamp": datetime.now().isoformat()
                }
            else:
                # Preparar datos
                df_clean = completed_df.copy()
                
                # Convertir tipos numÃ©ricos
                numeric_cols = ["amount", "unitPrice", "totalPrice"]
                for col in numeric_cols:
                    df_clean[col] = pd.to_numeric(df_clean[col], errors='coerce')
                
                # Fechas
                df_clean["fecha_hora"] = pd.to_datetime(df_clean["createTime"], unit="ms")
                df_clean["fecha"] = df_clean["fecha_hora"].dt.strftime('%Y-%m-%d')
                df_clean["hora"] = df_clean["fecha_hora"].dt.strftime('%H:%M:%S')
                
                # CÃ¡lculo USDT neto
                df_clean["usdt_neto"] = df_clean.apply(
                    lambda x: (x["totalPrice"]/x["unitPrice"]) * (1 - 0.0014) 
                    if x["tradeType"] == "SELL" 
                    else x["amount"] * (1 - 0.0014),
                    axis=1
                )
                
                # Resumen por dÃ­a
                resumen_diario = []
                for fecha, group in df_clean.groupby('fecha'):
                    ventas = group[group['tradeType'] == 'SELL']['usdt_neto'].sum()
                    compras = group[group['tradeType'] == 'BUY']['usdt_neto'].sum()
                    ganancia = ventas - compras
                    
                    resumen_diario.append({
                        'fecha': fecha,
                        'compras_usdt': round(float(compras), 2),
                        'ventas_usdt': round(float(ventas), 2),
                        'ganancia_usdt': round(float(ganancia), 2),
                        'operaciones': int(len(group))
                    })
                
                # Resultado final
                ganancia_total = sum(d['ganancia_usdt'] for d in resumen_diario)
                
                result = {
                    'success': True,
                    'timestamp': datetime.now().isoformat(),
                    'total_operaciones': int(len(df_clean)),
                    'ganancia_total': round(float(ganancia_total), 2),
                    'compras_total': round(float(sum(d['compras_usdt'] for d in resumen_diario)), 2),
                    'ventas_total': round(float(sum(d['ventas_usdt'] for d in resumen_diario)), 2),
                    'resumen_diario': resumen_diario,
                    'ultima_actualizacion': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }
                
                print(f"\nðŸ“Š RESUMEN FINAL")
                print(f"   Total operaciones: {result['total_operaciones']}")
                print(f"   Ganancia total: ${result['ganancia_total']:.2f}")
                print(f"   Compras total: ${result['compras_total']:.2f}")
                print(f"   Ventas total: ${result['ventas_total']:.2f}")
        
        # 3. Guardar resultados
        print("\n" + "=" * 60)
        print("ðŸ’¾ GUARDANDO RESULTADOS")
        print("=" * 60)
        
        os.makedirs('data', exist_ok=True)
        output_file = 'data/p2p-data.json'
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(result, f, ensure_ascii=False, indent=2)
        
        print(f"âœ… Datos guardados en: {output_file}")
        print(f"ðŸ“„ TamaÃ±o del archivo: {os.path.getsize(output_file)} bytes")
        
    except Exception as e:
        print(f"\nâŒ ERROR CRÃTICO: {e}")
        import traceback
        traceback.print_exc()
        
        # Guardar error
        error_result = {
            'success': False,
            'error': str(e),
            'timestamp': datetime.now().isoformat(),
            'message': 'Error durante la ejecuciÃ³n del script'
        }
        
        os.makedirs('data', exist_ok=True)
        with open('data/p2p-data.json', 'w', encoding='utf-8') as f:
            json.dump(error_result, f, ensure_ascii=False, indent=2)
        
        sys.exit(1)

if __name__ == '__main__':
    main()
EOF

    - name: Verificar que el script se creÃ³
      run: |
        echo "ðŸ“„ Contenido del script creado:"
        ls -la backend/p2p-api.py
        echo ""
        echo "Primeras 10 lÃ­neas:"
        head -10 backend/p2p-api.py
    
    - name: Ejecutar script con Secrets
      env:
        BINANCE_API_KEY: ${{ secrets.BINANCE_API_KEY }}
        BINANCE_API_SECRET: ${{ secrets.BINANCE_API_SECRET }}
      run: |
        echo "ðŸ”§ Variables de entorno:"
        echo "API_KEY: $(if [ -z "$BINANCE_API_KEY" ]; then echo 'NO DEFINIDA'; else echo 'DEFINIDA (${#BINANCE_API_KEY} caracteres)'; fi)"
        echo "API_SECRET: $(if [ -z "$BINANCE_API_SECRET" ]; then echo 'NO DEFINIDA'; else echo 'DEFINIDA (${#BINANCE_API_SECRET} caracteres)'; fi)"
        echo ""
        echo "ðŸš€ Ejecutando script Python..."
        python backend/p2p-api.py
    
    - name: Verificar resultado
      run: |
        echo "ðŸ“Š Verificando archivo de resultados..."
        if [ -f "data/p2p-data.json" ]; then
          echo "âœ… Archivo creado exitosamente"
          ls -la data/p2p-data.json
          echo ""
          echo "Contenido del archivo:"
          cat data/p2p-data.json
        else
          echo "âŒ No se creÃ³ el archivo de resultados"
          exit 1
        fi
    
    - name: Subir cambios al repositorio
      run: |
        echo "ðŸ“¤ Subiendo cambios..."
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add data/p2p-data.json backend/p2p-api.py
        git commit -m "ðŸ“Š Actualizar datos P2P - $(date)" || echo "No hay cambios nuevos"
        git push origin HEAD:main
      continue-on-error: true  # ContinÃºa aunque falle el push
